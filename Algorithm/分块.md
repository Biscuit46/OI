省选算法总结之
# 暴力数据结构-分块

其实分块的总结很早以前就写过了,只是现在再写一遍而已.

# 基本思路
我们按照一个固定的块的大小将数列分成若干个块,这个块的大小一般性是<a href="https://www.codecogs.com/eqnedit.php?latex=\sqrt{n}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\sqrt{n}" title="\sqrt{n}" /></a>或<a href="https://www.codecogs.com/eqnedit.php?latex=n^{\frac{2}{3}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n^{\frac{2}{3}}" title="n^{\frac{2}{3}}" /></a>,然后对于每一个块维护一些东西;对于一个查询,块内的区间操作,块外的暴力乱搞就可以了.

# Problem1

[POJ3468 http://poj.org/problem?id=3468](http://poj.org/problem?id=3468)

--------
直接搞就好了,对于块内的维护一个sum和一个atag(加法标记),询问的时候直接加起来就好了.


# Problem2
[BZOJ2724 https://www.k-xzy.xyz/BZPRO/JudgeOnline/2724.html](https://www.k-xzy.xyz/BZPRO/JudgeOnline/2724.html)  

--------
比较有思维难度，我们考虑一下众数可能是哪一些数：
1. 所以整体块中的数
2. 外面边角块中出现过的数

直接维护两个数组，然后一个一个判断就好了。
```cpp
#include<math.h>
#include<stdio.h>
#include<stdlib.h>
#include<map>
#include<vector>
#include<string.h>
#include<algorithm>
using namespace std;
int n,m,B,id;
int v[50010],bl[50010];
map<int,int>M;
int val[50010],cnt[50010];
int f[510][510];
vector<int>g[50010];
void pre(int x){
    memset(cnt,0,sizeof(cnt));
    int mx=0,ans=0;
    for(int i=(x-1)*B+1;i<=n;i++){
	cnt[v[i]]++;
	int t=bl[i];
	if(cnt[v[i]]>mx || (cnt[v[i]]==mx && val[v[i]]<val[ans]))ans=v[i],mx=cnt[v[i]];
	f[x][t]=ans;
    }
}
int query(int l,int r,int x){
    int t=upper_bound(g[x].begin(),g[x].end(),r)-lower_bound(g[x].begin(),g[x].end(),l);
    return t;
}
int query(int a,int b){
    int ans,mx;
    ans=f[bl[a]+1][bl[b]-1];
    mx=query(a,b,ans);
    for(int i=a;i<=min(bl[a]*B,b);i++){
	int t=query(a,b,v[i]);
	if(t>mx || (t==mx && val[v[i]]<val[ans]))ans=v[i],mx=t;
    }
    if(bl[a]!=bl[b])
	for(int i=(bl[b]-1)*B+1;i<=b;i++){
	    int t=query(a,b,v[i]);
	    if(t>mx || (t==mx && val[v[i]]<val[ans]))ans=v[i],mx=t;
	}
    return ans;
}
int main(){
    scanf("%d%d",&n,&m);B=sqrt(n);
    for(int i=1;i<=n;i++){
	scanf("%d",&v[i]);
	if(M.find(v[i])==M.end()){
	    M[v[i]]=++id;val[id]=v[i];
	}
	v[i]=M[v[i]];
	g[v[i]].push_back(i);
    }
    for(int i=1;i<=n;i++)bl[i]=(i-1)/B+1;
    for(int i=1;i<=bl[n];i++)pre(i);
    int ans=0;
    while(m--){
	int a,b;scanf("%d%d",&a,&b);
	a=(a+ans-1)%n+1,b=(b+ans-1)%n+1;
	if(a>b)swap(a,b);
	ans=val[query(a,b)];
	printf("%d\n",ans);
    }
    return 0;
}
```
# 代码地址
- [POJ3468 https://github.com/Biscuit46/OI/blob/master/Algorithm/Blocks/POJ3468.cpp](https://github.com/Biscuit46/OI/blob/master/Algorithm/Blocks/POJ3468.cpp)

- [BZOJ2724 https://github.com/Biscuit46/OI/blob/master/Algorithm/Blocks/BZOJ2724.cpp](https://github.com/Biscuit46/OI/blob/master/Algorithm/Blocks/BZOJ2724.cpp)
